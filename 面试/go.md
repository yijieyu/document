# [go资源文档](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/) 


### 调度

##### 调度器版本发展

- 单线程调度器
    - 程序中只能存在一个活跃线程，由G-M模型组成
    
- 多线程调度器1.0
    - 允许运行多个线程程序
    - 全局锁竞争严重
    
- 任务窃取调度器 1.1
    - 引入处理器P，构成了目前G-M-P模型
    - 在处理器P的基础上实现了基于工作窃取的调度器
    - 在某些情况，Goroutine不会让出线程，进而造成饥饿问题
    - 时间过长的垃圾回收（STW）会导致程序长时间无法工作
    
- 抢占式调度器 1.2 ~
     
    - 基于协作的抢占式调度器 1.12~1.13
        - 通过编译器在函数调用时插入抢占检查指令，在函数调用时检查当前Goroutine是否发起了抢占请求，实现了基于协作的抢占式调度
        - Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停
    
    - 基于信号的抢占式调度器 1.14 ~
        - 实现基于信号的真抢占式调度
        - 垃圾回收在扫描栈时会触发抢占调度
        - 抢占的时间点不够多，还不能覆盖全部的边缘情况（现有STW和栈扫描是可以抢占的安全点）

##### 目前调度器

1. G - 表示Goroutine， 是一个待执行任务
2. M - 表示操作系统的线程，由操作系统的调度器调度和管理
3. P - 表示处理器，它可以被看做运行在线程上的本地调度器

##### G

获取Goroutine的方式
1、为了保证公平，当全局运行队列有待执行的Goroutine时，通过schedtick保证有一定几率会从全局的队列中查找对应的Goroutine
2、从处理器本地的运行队列中查找待执行的Goroutine
3、从网络轮询器中查找是否有Goroutine等待执行
4、尝试从其他的随机处理器中窃取待执行的Goroutine，在该过程中还可能窃取处理器中的计时器


##### 基于协作式调度
> 就是主动让出处理器，允许其他Goroutine运行。 该函数无法挂起Goroutine，调度器会在自动调度当前的Goroutine
让出当前的处理器并将 Goroutine 重新放回全局队列

##### 基于信号调度





##### M 

Go语言并发模型中的 M 是操作系统线程。 最多只会有GOMAXPROCS个活跃线程正常运行
在多数情况下，我们都会使用Go的默认值，也就是线程数等于CPU个数，在这种情况下不会触发操作系统的线程调度和上下文切换

##### P

调度器中的处理器P是线程和Goroutine的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，
通过处理器P的调度，每一个内核线程都能够执行多个Goroutine，它能在Goroutine进行一些I/O操作时及时切换，提高线程的利用率

因为调度器在启动时就会创建GOMAXPROCS个处理器，所以Go语言程序的处理器数量一定会等于GOMAXPROCS，
这些处理器会绑定到不同的内核线程上并利用线程的计算资源运行Goroutine


### gc 标记三色法清除 

### 上下文context包

> 主要作用 还是在多个Goroutine组成的树中同步取消信号以减少对资源的消耗和占用，虽然它也有传值，但是这个功能很少用到

> 实际应用： 父级Goroutine 传给子goroutine， 子goroutine监听ctx的Done的取消信号


### 同步原语与锁

##### Once

> 用于单例模式， 每次只会执行一次


### channel

> 先入先出
