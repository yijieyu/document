# 计算机

[转载地址](https://www.jianshu.com/p/dfd940e7fca2)



1、支持一个进程所能打开的最大连接数

|  |  |
| --- | --- |
| select | 单个进程所能打开的最大连接数由FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64），当然这个值是可以做修改的，然后重新编译内核，但是性能可能会收到影响，这需要进一步的测试 |
| poll | poll本质上和select没有区别，但是它没有最大连接数的限制，原因是 它基于链表来存储的 |
| epoll | 虽然连接数有上限，但是很大，1G内存的机器上可以打开10W左右的链接，2G内存的机器可以打开20W左右的链接 |

2、FD剧增后带来的IO效率问题

|  |  |
| --- | --- |
| select | 因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题” |
| poll | 同上，遍历链表 |
| epoll | 因为epoll内核中实现是根据每个fd的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的，也可能有性能问题 |


3、消息传递方式

|  |  |
| --- | --- |
| select | 内核需要将消息传递到用户空间，都需要内核拷贝动作 |
| poll | 同上 |
| epoll | epoll通过内核和用户空间共享一块内存来实现的 |



总结：

综上，在select，poll，epoll 时要根据具体的使用场合以及这三种方式的自身特点决定

1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况，select和poll比epoll更好，毕竟epoll的通知机制

需要很多函数回调

2、select低效时因为每次它都需要轮询，但低效也是相对的，也可通过良好的设计改善。






为什么nginx用 master-worker的进程、进程模型， redis采用 进程、线程模型

nginx 是为了处理更多的链接请求
redis 是为了更快的处理请求 ，多线程/多进程会因为并发竞争加锁以及上下文切换，效率变低

##### redis 采用进程、线程模型
1、非阻塞IO - IO多路复用，Redis采用epoll做为I/O多路复用技术的实现，
再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。
2、多线程处理可能涉及到锁，多线程处理会涉及到线程切换而消耗CPU
3、采用单线程,避免了不必要的上下文切换和竞争条件



##### 进程、线程、协程 区别


进程是指在系统中正在运行的一个应用程序，是系统进行资源分配和调度的一个独立单位
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。
协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，
直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。


