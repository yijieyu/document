# redis 


### redis 数据类型
- 字符串 value 最大为512M
- 字典hash 个数最多为2^32-1
- 链表list 个数最多为2^32-1
- 有序集合zset (sorted set)  个数最多为2^32-1
- 集合set 个数最多为2^32-1
- pub/sub (订阅)


### redis 分布式锁
`先使用setnx来争夺锁，抢到之后，使用expire给锁加过期时间。在使用expire之前因异常导致程序中断，锁将一致存在无法释放
所以这两个命令需要原子操作，使用setnx 直接给锁加上过期时间`

 
### redis 数据淘汰策略
- noeviction 禁止淘汰数据
- allkeys-lru: 所有key通用；优先删除最近最少使用的key
- volatile-lru: 仅限于设置了过期（expire）的键，尝试回收最少使用的键（LRU），优先删除最近最少使用的key
- allkeys-random：所有key通用；随机删除一部分key
- volatile-random：仅限于设置了过期（expire）的键，随机删除一部分key，优先删除最近最少使用的key
- volatile-ttl：仅限于设置了expire的部分；并且优先回收存活时间（TTL）较短的键

### 如果有大量的key需要设置同一时间过期

如果大量的key设置的时间过于集中，到过期点，redis可能会出现短暂的卡顿现象，是因为redis要处理过期的key值
一般需要在时间上加一个随机值，使得过期时间分散

### bgsave 做镜像全量持久化原理
 
fork 和 cow。fork是指redis通过创建子进程来进行bgsave操作，cow是指copy on write， 子进程创建后，
父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开

### pipeline 有什么好处

可以将多次IO往返的时间缩减为一次，前提是pipeline 执行的指令之间没有因果相关性


### 缓存穿透/ 缓存击穿 / 缓存雪崩

- 缓存穿透： key对应的数据源不存在，每次针对此key的请求从缓存取不到，请求都会到数据源，从而可能压垮数据库
- 缓存击穿： key对应的数据源存在，但在redis中过期了，此时若有大量并发请求过来，这些请求发现缓存过期，一般都会从后端DB中加载
数据库并缓存，这个时候大并发请求可能会瞬间把数据库压垮
- 缓存雪崩：当缓存服务器重启或者大量的缓存集中在某个时间段失效，这样在失效的时候，也会把请求落在数据源，造成压力

##### 缓存穿透的解决方法
有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，
将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，
从而避免了对底层存储系统的查询压力。
另外也有一个更为简单粗暴的方法（我们采用的就是这种），
如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，
但它的过期时间会很短，最长不超过五分钟

##### 缓存击穿的解决方法

业界比较常用的做法，是使用mutex。
简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，
而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，
当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。

##### 缓存雪崩的解决方法
- 避免大量的key在同一时间失效
- 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1 缓存失效设置为短期，A2设置为长期

### 集群不能选在数据库
 默认为0
 
### redis 事务
- 事务是一个单独的隔离操作： 事务中的所有的命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求中断

事务是一个原子操作：事务中的命令要么全部失败，要么全部不执行
通常使用 multi, exec,discard,watch 这几个命令操作
