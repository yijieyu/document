# mysql

[转载1](https://juejin.im/post/6844903824935632909)
[转载2](https://www.cnblogs.com/cxuanBlog/p/12724257.html)

>.InnoDB支持事物，而MyISAM不支持事物

>.InnoDB支持行级锁，而MyISAM支持表级锁

>.InnoDB支持MVCC, 而MyISAM不支持

>.InnoDB支持外键，而MyISAM不支持

>.InnoDB不支持全文索引，而MyISAM支持。

1 InnoDB 支持表锁和行锁，使用索引作为检索条件修改数据时采用行锁，否则采用表锁。
2 InnoDB 自动给修改操作加锁，给查询操作不自动加锁
3 行锁可能因为未使用索引而升级为表锁，所以除了检查索引是否创建的同时，也需要通过explain执行计划查询索引是否被实际使用。
4 行锁相对于表锁来说，优势在于高并发场景下表现更突出，毕竟锁的粒度小。
5 当表的大部分数据需要被修改，或者是多表复杂关联查询时，建议使用表锁优于行锁。
6 为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接影响到一个数据库的并发处理能力和性能。



# 行锁

InnoDB只有在通过索引条件检索数据时使用行级锁

## 事务的隔离性(ACID) 
`事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。`
  - 原子性：事务是一个原子操作。 对数据的操作修改， 要么全部成功，要么全部失败
  - 一致性：在事务开始和结束后，数据都要保持一致的状态。意味着所有的相关数据规则都必须应用于事务的修改，以保持数据的完整性
           事务结束时，所有的内部数据结构也都必须是正确的
  - 隔离性：数据库系统给事务执行操作提供一定的隔离环境。
    也就是每个事务都是相对独立运行的，保证当前事务不受其他事务运行干扰，这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然
  - 持久性： 事务操作完成后。对于数据的修改具有永久性，即使出现系统故障也能保持。  

## 并发事务带来的影响

更新丢失
原因：当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题


脏读
原因：事务A读取了事务B已经修改但尚未提交的数据。若事务B回滚事务，那么事务A的数据存在不一致性的问题

不可重复读：
原因：事务A第一次读取最初数据，第二次读取时事务B已经提交了修改或删除数据。导致两次读取数据不一致。不符合事务的隔离性

幻读
原因：事务A根据相同条件第二次查询到的事务B提交的新增数据，两次数据结果集不一致

幻读和脏读类似
脏读是事务B里面修改了数据
幻读是事务B里面新增了数据

## 事务隔离级别

| 隔离级别| 脏读 | 不可重复读 | 幻读 |
| ---| ---| ----| --- |
| 读未提交 | 可能  | 可能 | 可能 |
| 读已提交 | 不可能 | 可能 | 可能 |
| 可重复读 | 不可能 | 不可能 | 可能 |
| 可串行化 | 不可能 | 不可能 | 不可能 |


数据库的事务隔离级别越严格，并发副作用越小，但付出的代价也越大，
因为事务隔离实质上就是事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。
同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，许多应用对“不可重读”和“幻读”并不敏感，
可能更关心数据的并发访问的能力。

### mysql 事务四大特性 innodb

- 原子性

在事务执行操作，要么全部成功，要么全部失败

- 一致性

 是一个事务在执行前后其状态一致。比如，A/B共1000元， 无论 AB之前怎么转账，两人之和都必须满足1000元 

- 持久性

事务操作完成后，对数据的操作具有永久性，即使数据库遇到特殊情况比如故障也不会产证干扰

- 隔离性
当多个事务同时执行操作时，会有产生脏读/不可重复读/幻读，为了解决并发问题，提出隔离性
    - 脏读 
    - 不可重复读 在A事务中多次读取数据，A事务中间读取数据时被其他事务做了更新操作并提交，导致A事务在提交后读取数据不一致了
    - 幻读  一个事务执行相同的条件的操作， 却发现有新的数据满足条件

##### 隔离级别

- 读未提交 指的是一个事务在提交之前，做的修改就可以被其他事务所看到

- 读已提交 指的是一个事务在提交之后，做的修改才可以被其他事务所看到

- 可重复读 指的是一个事务在执行的过程中，看的数据是和其他的数据是一致的，未提交的修改不被其他事务所看到

- 串行化 指的是对于同一行数据，读写都会加锁，当出现读写锁冲突的时候，后访问的事务必须等前一个事务操作完成后，才可以继续执行

其中隔离级别由低到高是：读未提交 < 读已提交 < 可重复读 < 串行化
隔离级别越高，越能够保证数据的完整性和一致性，但是对并发的性能影响越大。大多数数据库的默认级别是读已提交


普通索引，联合索引，唯一索引，主键索引，全文索引


### 索引的使用方法

##### 匹配原则

最左匹配原则

- 对于联合索引，MySQL 会一直向右匹配直到遇到范围查询（> ， < ，between，like）就停止匹配。
比如 a = 3 and b = 4 and c > 5 and d = 6，如果建立的是（a,b,c,d）这种顺序的索引，
那么 d 是用不到索引的，但是如果建立的是 （a,b,d,c）这种顺序的索引的话，那么就没问题，
而且 a，b，d 的顺序可以随意调换。
- = 和 in 可以乱序，比如 a = 3 and b = 4 and c = 5 建立 （a，b，c）索引可以任意顺序。
- 如果建立的索引顺序是 （a，b）那么直接采用 where b = 5 这种查询条件是无法利用到索引的，
这一条最能体现最左匹配的特性。


##### 主键与数据存放关系
B+Tree 数据都存放在叶子节点上，非叶子结点存放主键id

##### 主键索引

##### 非主键索引 
也就是 Innodb使用非主键索引查找的过程

非主键索引存放的方式： 索引值放在非叶子节点数据，叶子节点数据存放主键与索引

所以查询方式，则是以先通过非主键索引查询到主键数据
然后拿主键数据通过主键索引查询，得到数据

##### 覆盖索引

如果select 查询的字段 正好被联合索引数据所覆盖，那么会直接返回数据，并不需要再用主键数据走一遍主键索引搜索了



联合索引（A,B）,select ... from ...where B = 'xxx' and A = 'xxx'可以命中索引吗



### sql优化

##### explain 使用

explain 不同的字段类型

type 描述

- system 表中仅有一行数据，这是const联结类型的一个特例
- const 表示通过索引一次就找到，const用于比较主键或者唯一索引。因为只匹配一行数据，所以如果将主键至于where列表中，mysql能将该查询转换为一个常量
- er_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于唯一索引和主键扫描
- ref 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体
- range 只检索给定范围的行，使用一个索引来选择行。key列现实使用了哪个索引，一般就是where语句中出现了between in等范围的查询
这种范围查询扫描索引扫描比全表扫描要好，因为它开始与索引的某个点，而结束另一个点，不用全表扫描
- index index与all区别为 index类型只遍历索引树。通常比all快，因为索引文件比数据文件小很多
- all  全表扫描找到匹配的行


##### sql 执行语句方式

```sql
select distinct 
        <select_list>
from
    <left_table><join_type>
join <right_table> on <join_condition>
where
    <where_condition>
group by
    <group_by_list>
having
    <having_condition>
order by
    <order_by_condition>
limit <limit number>
```

```sql
from <left_table><join_type>
on <join_condition>
<join_type> join <right_table>

where <where_condition>

group by <group_by_list>

having  <having_condition>

select 

distinct  <select_list>

order by <order_by_condition>

limit <limit_number>


```

