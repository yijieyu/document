# 锁

### 事务隔离读取方式

- 读已提交
> 总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新的一个快照

- 可复重读
> 总是读取事务开始时的行数据，因此对于可重复读事务隔离级别
 
### 锁

##### 锁类型
- 行锁

```text
针对同一行数据，同一行数据，读锁是可以兼容，写与读是排斥的；举例：针对同一行数据，事务A先加读，未提交，未释放锁；
此时事务B加写锁，由于有事务A在进行读，会被阻塞。 只能等事务A释放锁，才能再加写锁。
读与读可以兼容，读与写排斥，写与写排斥

如果事务A先加写锁，未释放锁，事务B不加锁读，则不会等待，而会获取到最新版本的数据，非锁定读
```

> 共享锁（读锁）（S lock） 允许事务读一行数据
> 排他锁（写锁）（X lock） 允许事务删除或更新一行数据

- 意向锁（表锁）[讲解意向锁](https://juejin.cn/post/6844903666332368909)

```text

首先 意向锁是不与行级锁冲突的表级锁
对表加锁，目的是为了在一个事务中揭示下将被请求的锁类型

mysql技术内幕Innodb 266页 254 6-4图上文字说"故表级意向锁与行级锁的兼容性表" 这里有误 意向锁不与行级锁冲突
所以应该是 故表级意向锁与表级意向锁的兼容性表
```

> 意向共享锁（IS lock） 事务想要获取一张表中某几行的共享锁

```text
事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
```

> 意向排他锁（IX locks）事务想要获取一张表中的几行排他锁

```text
事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
```

```text
意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，
InooDB 会先获取该数据行所在在数据表的对应意向锁
```

1. InnoDB 支持多粒度锁，特定场景下，行级锁可以与表级锁共存。
2. 意向锁之间互不排斥，但除了 IS 与 S 兼容外，意向锁会与 共享锁 / 排他锁 互斥。
3. IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。
4. 意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。

##### 一致性非锁定读

- 作用
> 能提高访问速度，以及提高数据库的并发性

- 为什么
> 快：不需要等待访问的行上X锁释放

> 并发性：是Innodb存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据，如果读取的行正在进行DELETE或UPDATE操作，
这时读取操作不会因此去等待行上锁的释放。相反的地，Innodb存储引擎会去读取行的一个快照数据

> 快照数据是指该行的之前版本的数据，该实现是通过undo 段来完成。undo用来在事务中回滚数据

- 事务针对快照数据

> 事务级别为read committed（读已提交）：总是读取被锁定行的最新一份快照数据，也就是只要其他事务提交修改，获取的就是修改后的数据
> 事务级别为repeatable read（可重复读）：总是读取事务开始时的行数据版本，由于事务的隔离性，也就是说即使其他数据提交修改了，
也获取不到其他事务修改后的最新数据，也只能获取事务开始的获取的罪行行数据版本， 事务的隔离性

##### 一致性锁定读

```text
有时需要对数据读取操作进行枷锁以保证数据逻辑的一致性
```

```sql

-- 加排他锁（写锁）
select * from table_name where id = xxx for update;

-- 加共享锁（读锁）
select * from table_name where id = xxx lock in share mode;

-- 查看锁状态
show OPEN TABLES where In_use > 0;

```

##### 锁问题

- 脏读 - 隔离级别：读未提交
```text
 是指一个事务读取到另一个事务修改后未提交的数据
```
- 不可重复读 隔离级别：读已提交
```text
是指在同一个事务里，能获取另一个事务修改后提交的数据，导致同一条sql执行结果前后不一致
```

- 幻读 
```text
是指在同一个事务里，能获取另一个事务新增的数据，导致获取的数据条数不一致
```